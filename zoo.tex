\documentclass[]{article}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\newtheoremstyle{break}
{\topsep}{\topsep}%
{\itshape}{}%
{\bfseries}{}%
{\newline}{}%
\theoremstyle{break}
\theoremstyle{break}
\newtheorem{definition}{Definition}[section]
\newtheorem{problem}{Problem}[section]
\newtheorem{theorem}{Theorem}[section]
\begin{document}
	
\section{Complexity Zoo}

\subsection{TIME[$f(n)$]}
\label{sec:TIME}
Informally: problems that can be solved in $f(n)$ time. 
\begin{definition}
	Given some function $f : \mathbb{N} \to \mathbb{N}$, $\text{TIME}[f(n)]$ are the set of problems solvable within $O(f(n))$ atomic steps on a deterministic Turing machine. Where $n$ is the size of the input.
\end{definition}

\subsection{NTIME[$f(n)$]}
\label{sec:NTIME}
Informally: problems that can be solved nondeterministically in $f(n)$ time. 
\begin{definition}
	Given some function $f : \mathbb{N} \to \mathbb{N}$, $\text{NTIME}[f(n)]$ are the set of problems solvable within $O(f(n))$ atomic steps on a nondeterministic Turing machine.
\end{definition}

\subsection{SPACE[$f(n)$]}
\label{sec:SPACE}
Informally: problems that can be solved in $f(n)$ space. 
\begin{definition}
	Given some function $f : \mathbb{N} \to \mathbb{N}$, $\text{SPACE}[f(n)]$ are the set of problems solvable using a tape of length $O(f(n))$ on a deterministic Turing machine. Where $n$ is the size of the input.
\end{definition}

\subsection{NSPACE[$f(n)$]}
\label{sec:NSPACE}
Informally: problems that can be solved non-deterministically in f(n) space. 
\begin{definition}
	Given some function $f : \mathbb{N} \to \mathbb{N}$, $\text{NSPACE}[f(n)]$ are the set of problems solvable using a tape of length $O(f(n))$ on a non-deterministic Turing machine. Where $n$ is the size of the input.
\end{definition}

\subsection{SIZE[t]}
\label{sec:size}
Informally: problems that can be solved by a circuit of size t(n)
\\
Formally:
\begin{definition}
	A language L is in SIZE[t] if there is a t(n)-size circuit
	family $ \{ C_n \}_{n\in \mathbb{N}} s.t. \forall x \in \{0, 1\}^n, x \in L \iff C_n(x) = 1.$
\end{definition}

\subsection{$\mathbf{P}$}
\label{sec:P}
Informally: all problems that can be solved in polynomial time.
\begin{definition}
	$$\mathbf{P} = \bigcup_{k\geq 0} \hyperref[sec:TIME]{\text{TIME}}[n^{k}]$$
\end{definition}
$ $
\\
\\
Descriptive Complexity definitions: 
\begin{definition}
	$$\mathbf{P} = \text{FO(LFP)}$$
(First Order logic extended with the Least Fixed Point operator, with successor. A high level, handwavy description of the LFP operator is the added ability to recursively define FO formulas.)
\end{definition}
\begin{definition}
	$$\mathbf{P} = \text{SO(Horn)}$$
(Second Order logic restricted with Horn. SO logic allows you to quantify over subsets/relations/functions on the domain, and Horn means all `clauses' are really implications with literal in the conclusion and all literals positive.)
\end{definition}
$ $
\\
\\
Circuit Complexity definitions:
\begin{definition}
	$$\textbf{P} = \textbf{P}-\text{uniform}$$
	$\textbf{P}-\text{uniform} = $ Set of circuit families$\{C_n\}_{n\in\mathbb{N}}$ for which there is a Turing Machine that on input $1^n $ outputs the description of $ C_n$ in polynomial time.
\end{definition}
\begin{definition}
	$$\textbf{P} = \hyperref[sec:L]{\textbf{L}}-\text{uniform}$$
	$\textbf{L}-\text{uniform} = $ Set of circuit families$\{C_n\}_{n\in\mathbb{N}}$ for which there is a Turing Machine that on input $1^n $ outputs the description of $ C_n$ using logarithmic space. 
\end{definition}
$ $
\\
\\
Notable Problems in $\mathbf{P}$:
\begin{itemize}
	\item 2-SAT
	\item 2-Colourability
	\item Reachability
\end{itemize}
\subsection{$\mathbf{NP}$}
\label{sec:NP}
Informally: all problems that can be solved in nondeterministic polynomial time.
\begin{definition}
	$$\mathbf{NP} = \bigcup_{k\geq 0} \hyperref[sec:NTIME]{\text{NTIME}}[n^{k}]$$
\end{definition}
$ $
\\
Turing Machine definition:
\begin{definition}
	$$x \in \mathbf{NP}\iff \exists w : \|w\| \leq p(\|x\|) \text{ s.t. } M(x, w) = 1$$
\end{definition}
$ $
\\
\\
In terms of a verifier:
\\
Informally: The set of decision problems where a solution can be verified in polynomial time.
\\
\\
Descriptive Complexity Definition:
\begin{definition}
	$$\mathbf{NP} = \text{SO}\exists$$
	(Existential Second Order)
\end{definition}
$ $
\\
\\
Notable Problems in $\mathbf{NP}$:
\begin{itemize}
	\item SAT
	\item 3-Colourability
	\item TSP
	\item Subset sum
\end{itemize}
\subsection{coNP}
\label{sec:coNP}
Turing Machine definition:
\begin{definition}
	$$x \in \mathbf{coNP}\iff \forall w : \|w\| \leq p(\|x\|) \text{s.t.} M(x, w) = 1$$
\end{definition}
$ $
\\
\\
In terms of a verifier:
\\
Informally: The set of decision problems where a solution can be refuted in polynomial time.
\subsection{FPT}
\label{sec:FPT}
Informally, the set of problems that can be solved in polynomial time for some fixed parameter.
\\
\begin{definition}
	The set of problems that can be parameterised by $k$ and can be solved in $f(k)n^c$, where $f(x)$ is only dependent on $k$, and $c$ is an independent constant.
\end{definition}
$ $
\\
\hyperref[sec:P]{$\mathbf{P}$} is contained within $\mathbf{FPT}$.
\\
If a problem is in $\mathbf{FPT}$, then for any fixed $k$ that problem is in \hyperref[sec:P]{$\mathbf{P}$}.
\\
$\mathbf{FPT}$ is also known as \hyperref[sec:W]{$\mathbf{W[0]}$}
$ $
\\
\\
Notable Problems in $\mathbf{FPT}$:
\begin{itemize}
	\item Vertex Cover
\end{itemize}
\subsection{W[1]}
\label{sec:W[1]}

\begin{definition}
	The class of parametrized problems that admit a parametrized reduction to the following problem:
	Given a	nondeterministic single-tape Turing machine, decide if it accepts within k steps.
\end{definition}
N.B This is short acceptance
\begin{definition}
	The class of parametrized problems that admit a parametrized reduction to the following problem:
	Given a Boolean circuit C, with a mixture of fanin-2 and unbounded-fanin gates. There is at most 1 unbounded-fanin gate along any path to the root, and the total depth (fanin-2 and unbounded-fanin) is constant. Does C have a satisfying assignment of Hamming weight k?
\end{definition}
N.B This is Weighted 3-SAT.
\\
\\
Notable Problems in $\mathbf{W[1]}$:
\begin{itemize}
	\item Short Acceptance
	\item Weighted 3-SAT
	\item Clique (of size k)
	\item Independent set (of size k)
\end{itemize}
\subsection{W[2]}
\subsection{W[i]}
\label{sec:W}
\subsection{FPTAS} \label{sec:FPTAS}

\begin{definition}
	An algorithm $A$ is a full polynomial-time approximation scheme (FPTAS) if, for any instance $x$ and any $\epsilon > 0$, $A$ computes a $(1 + \epsilon)$-approximate solution in time polynomial in both $|x|$ and $\frac{1}{\epsilon}$.
\end{definition}

\begin{definition}
	$\mathbf{FPTAS}$ is the class of all problems that admit a full polynomial-time approximation scheme.
\end{definition}
$ $
\\
Notable problems in $\mathbf{FPTAS}$:
\begin{itemize}
	\item Minimum Partition
	\item Maximum Knapsack
\end{itemize}

\subsection{PTAS}

\begin{definition}
	An algorithm $A$ is a polynomial-time approximation scheme (PTAS) if, for any instance $x$ and any $\epsilon > 0$, $A$ computes a $(1 + \epsilon)$-approximate solution in time polynomial in $|x|$.
\end{definition}

\begin{definition}
	$\mathbf{PTAS}$ is the class of all problems that admit a polynomial-time approximation scheme.
\end{definition}

\subsection{L}
\label{sec:L}
Informally: all problems that can be solved using logarithmic space (excluding the input)
\\
\begin{definition}
	$$\mathbf{L} = \hyperref[sec:SPACE]{\text{SPACE}[\log n]}$$
\end{definition}
$ $
\\
This means you effectively have the input and then a fixed number of counters/pointers (up to the size of the input)
\\
\\
Notable Problems in $\mathbf{L}$:
\begin{itemize}
	\item Planar Graph Isomorphism
\end{itemize}
\subsection{NL}
\label{sec:NL}
Informally: all problems that can be solved using nondeterministic logarithmic space (excluding the input)
\\
\begin{definition}
	$$\mathbf{NL} = \hyperref[sec:NSPACE]{\text{NSPACE}[\log n]}$$
\end{definition}
$ $
\\
This means you effectively have the input and then a fixed number of counters/pointers (up to the size of the input)
\\
\begin{definition}
	$$\mathbf{NL} = \text{SO(Krom)}$$
\end{definition}
$ $
\\
\begin{definition}
	$$\mathbf{NL} = \mathbf{coNL}$$
\end{definition}
$ $
\\
Notable Problems in $\mathbf{NL}$:
\begin{itemize}
	\item Reachability
	\item Unreachability
\end{itemize}

\subsection{AP} \label{sec:AP}

\begin{definition}[Alternating Turing Machine]
	An Alternating Turing Machine is a non-deterministic TM $M$ whose states $Q$ are divided into two parts, $Q_{\text{AND}}$ and $Q_{\text{OR}}$. An eventually accepting configuration (e.a.c.) on an input $x$ is defined as follows:
	
	\begin{itemize}
		\item All accepting leaves in the computation tree $M(x)$ are e.a.c.
		\item A configuration with state in $Q_{\text{AND}}$ is e.a.c. iff all of its successor states are e.a.c.
		\item A configuration with state in $Q_{\text{OR}}$ is e.a.c. iff at least one of its successor states are e.a.c.
	\end{itemize}
	
	An Alternating TM $M$ accepts $x$ iff the initial configuration of $M(x)$ is e.a.c.
\end{definition}

\begin{definition}
	$\mathbf{AP}$ is the set of all problems decidable in polynomial time by an Alternating TM.
\end{definition}

\subsection{PSPACE} \label{sec:PSPACE}

Informally: all problems that can be solved using polynomial space on the size of the input.

\begin{definition}
	$$\mathbf{PSPACE} = \bigcup_{k \geq 0} \hyperref[sec:SPACE]{\text{SPACE}[n^k]}$$
\end{definition}

\begin{definition}
	$$\mathbf{PSPACE} = \hyperref[sec:AP]{\mathbf{AP}}$$
\end{definition}

\begin{definition}
	$$\mathbf{PSPACE} = \hyperref[sec:NPSPACE]{\mathbf{NPSPACE}}$$
\end{definition}

\subsection{$\Sigma^p_2$}
\label{sec:sigmap2}
\begin{definition}
	$$\Sigma_2^P = \hyperref[sec:NP]{\textbf{NP}^{\textbf{NP}}}$$
\end{definition}
$ $
\\
Turing Machine definition:
\begin{definition}
	$$x \in \Sigma_2^P\iff \exists w : \|w\| \leq p(\|x\|) \forall u : \|u\| \leq p(\|x\|)\text{s.t.} M(x, w,u) = 1$$
\end{definition}
\subsection{$\Sigma^p_i$}
\label{sec:sigmapi}
\begin{definition}
	$$\Sigma_i^P = \hyperref[sec:NP]{\textbf{NP}}^{\hyperref[sec:sigmapi]{\Sigma_{i-1}^P}}$$
\end{definition}
$ $
\\
Turing Machine definition:
\begin{definition}
	$$x \in \Sigma_i^P\iff \exists u_1\forall u_2 ... Q_i u_i M(x,u_1,...,u_i) = 1$$
	$|u_j| \leq p(x)$ and $Q_i=\forall/\exists$ if $i$ is even/odd.
\end{definition}
$ $
\\
\begin{definition}
	$$\Sigma_i^p ={\hyperref[sec:pipi]{co-\Pi_{i}^p}}$$
\end{definition}
\subsection{$\Pi^p_2$}
\label{sec:pip2}
\begin{definition}
	$$\Pi_2^P = \hyperref[sec:coNP]{\textbf{coNP}^{\textbf{NP}}}$$
\end{definition}
$ $
\\
Turing Machine definition:
\begin{definition}
	$$x \in \Pi_2^P\iff \forall w : \|w\| \leq p(\|x\|) \exists u : \|u\| \leq p(\|x\|)\text{s.t.} M(x, w,u) = 1$$
\end{definition}
\subsection{$\Pi^p_i$}
\label{sec:pipi}
\begin{definition}
	$$\Pi_i^P = \hyperref[sec:coNP]{\textbf{coNP}}^{\hyperref[sec:sigmapi]{\Sigma_{i-1}^P}}$$
\end{definition}
$ $
\\
Turing Machine definition:
\begin{definition}
	$$x \in \Pi_i^P\iff \forall u_1\exists u_2 ... Q_i u_i M(x,u_1,...,u_i) = 1$$
	$|u_j| \leq p(x)$ and $Q_i=\exists/\forall$ if $i$ is even/odd.
\end{definition}
$ $
\\
\begin{definition}
	$$\Pi_i^p ={\hyperref[sec:sigmapi]{co-\Sigma_{i}^p}}$$
\end{definition}
\subsection{PH}
\label{sec:PH}
\begin{definition}
	$$\textbf{PH} =\bigcup_i\hyperref[sec:sigmapi]{\Sigma_{i}^p}$$
\end{definition}

\subsection{$P^{SAT}$}

\subsection{$\textbf{NP}^{\text{SAT}}$}
\label{sec:npsat}
$\textbf{NP}$ with a SAT oracle, equivalent to $\hyperref[sec:sigmap2]{\Sigma_2^p}$

\subsection{P/poly}
\label{sec:ppoly}
Circuit definition:
\begin{definition}
	$$\textbf{P/poly} = \bigcup_c \hyperref[sec:size]{\text{SIZE}[n^c]}$$
\end{definition}
$ $
\\
Turing Machine definition: decision problems solvable by a polynomial-time Turing machine that receives an 'advice string' that is polynomial is size.
\\
More formally:
\begin{definition}
		$$\textbf{P/poly} = \bigcup_{c,d} \hyperref[sec:time]{\text{TIME}[n^c]}/n^d$$
\end{definition}
\subsection{EXP}
Informally: Problems that take exponential time to solve.
\begin{definition}
	$$\textbf{EXP}= \bigcup_c \hyperref[sec:time]{\text{TIME}[2^{n^c}]}$$
\end{definition}
\subsection{$\textbf{NC}^0$}
\label{sec:NC0}
Constant size circuits.
\subsection{$\textbf{NC}^1$}
\label{sec:NC1}
Contains Parity.
\subsection{$\textbf{NC}^2$}
\label{sec:NC2}
Contains Reachability.
\subsection{$\textbf{NC}^i$}
\label{sec:NCi}
\begin{definition}
	$\textbf{NC}^i = $ all languages decidable by an \textbf{L}-uniform circuit family of polynomial size and depth $O(\log^i n)$
\end{definition}
\subsection{NC}
\label{sec:NC}
\begin{definition}
	$$\textbf{NC} = \bigcup_i \hyperref[sec:NCi]{\textbf{NC}^i}$$
\end{definition}
\subsection{$\textbf{AC}^0$}
\label{sec:AC0}
Constant size circuits with unbounded fan-in.
\subsection{$\textbf{AC}^i$}
\label{sec:ACi}
\begin{definition}
	$\textbf{AC}^i = $ all languages decidable by a non-uniform circuit family of polynomial size and depth $O(\log^i n)$
\end{definition}
\subsection{AC}
\label{sec:AC}
\begin{definition}
	$$\textbf{AC} = \bigcup_i \hyperref[sec:ACi]{\textbf{AC}^i}$$
\end{definition}

\subsection{BPP}
\label{sec:bpp}
\begin{definition}
	$L\in \textbf{BPP}$ if there is a PTM $M$ that runs in poly time s.t. :
	$$x \in L \implies 	Pr[M \text{ accepts } x]\geq \frac{2}{3}$$
	$$x \notin L \implies 	Pr[M \text{ rejects } x]\geq \frac{2}{3}$$
\end{definition}
This can be amplified to:
\begin{definition}
	$L\in \textbf{BPP}$ if there is a PTM $M$ that runs in poly time s.t. :
	$$x \in L \implies 	Pr[M \text{ accepts } x]\geq 1 - 2^{-p(n)}$$
	$$x \notin L \implies 	Pr[M \text{ rejects } x]\geq 1 - 2^{-p(n)}$$
\end{definition}
\subsection{RP}
\label{sec:rp}
\begin{definition}
	$L\in \textbf{RP}$ if there is a PTM $M$ that runs in poly time s.t. :
	$$x \in L \implies 	Pr[M \text{ accepts } x]\geq \frac{1}{2}$$
	$$x \notin L \implies 	Pr[M \text{ rejects } x] = 1$$
\end{definition}
This can be amplified to:
\begin{definition}
	$L\in \textbf{RP}$ if there is a PTM $M$ that runs in poly time s.t. :
	$$x \in L \implies 	Pr[M \text{ accepts } x]\geq 1 - 2^{-p(n)}$$
	$$x \notin L \implies 	Pr[M \text{ rejects } x] = 1$$
\end{definition}
\subsection{co-RP}
\label{sec:co-rp}
\begin{definition}
	$$\textbf{co-RP} = \{\bar{L}| L\in \hyperref[sec:rp]{\textbf{RP}} \}$$
\end{definition}
\begin{definition}
	$L\in \textbf{co-RP}$ if there is a PTM $M$ that runs in poly time s.t. :
	$$x \in L \implies 	Pr[M \text{ accepts } x] = 1$$
	$$x \notin L \implies 	Pr[M \text{ rejects } x] \geq 1 - 2^{-p(n)}$$
\end{definition}
\subsection{ZPP}
\label{sec:zpp}
\begin{definition}
	$$\textbf{ZPP} = \hyperref[sec:rp]{\textbf{RP}} \cap \hyperref[sec:co-rp]{\textbf{co-RP}}$$
\end{definition}

\subsection{APX}

\subsection{PO}

\subsection{PCP}

\subsection{BQP}

\subsection{$\# P$}

\subsection{TFNP}
Conventional complexity classes are concerned with decision problems, i.e., given a graph $G$ and some number $k$ determine whether or not $G$ has a clique of size $k$.\\
This loses its meaning when the answer is always `yes' - for example, does this bimatrix game have a mixed Nash equilibrium?\\
\begin{definition}
	TFNP is the set of binary relations $R(x, y)$ such that for every $x$ there exists at least one $y$ (which is at most polynomially larger than $x$) such that $R(x,y)$ holds.
	Algorithms that solve problems in this class take an input $x$ and produce some $y$ such that $R(x, y)$ holds, in polynomial time.
\end{definition}

\subsection{PPAD}
An example of a problem in TFNP is the following:
\begin{problem}
	\textsc{End of the line.} We are given a graph $G$ that is a disjoint union of directed paths - every vertex has at most one predecessor and at most one successor. This graph may be exponentially sized,
	but is given implicitly as a Turing machine computing the predecessor and successor of each node (if they exist, otherwise signals that this node is a sink/source).\\
	Given a source in $G$, can we find a sink, or any other source, in polynomial time?
\end{problem}

Of course, a sink always exists, but simply moving along successor edges may visit all (exponentially many) nodes of a graph.

\begin{definition}
	PPAD is the set of problems in TFNP reducible to \textsc{End of the line.}
\end{definition}

A notable problem in PPAD, which turns out to be PPAD-complete, is to compute a mixed Nash equilibrium of some bimatrix game.
\section{Problems}
\label{prob:colouring}
\begin{problem}[Colouring]
	\textit{Instance}: a graph $G$ and an integer $k$.
	\\
	\textit{Question}: does $G$ have a $k$-colouring.
\end{problem}
\label{prob:kcolouring}
\begin{problem}[$k$-Colouring]
	\textit{Instance}: a graph $G$.
	\\
	\textit{Question}: does $G$ have a $k$-colouring.
\end{problem}
\section{Theorems}
\begin{theorem}[Lov\'asz, 1973]
	\hyperref[prob:kcolouring]{3-Colouring} is \hyperref[sec:NP]{NP-Complete}
\end{theorem}
\begin{theorem}[Appel \& Haken, 1977]
	Every planar graphs is\hyperref[prob:kcolouring]{4-colourable} 
\end{theorem}
\begin{theorem}[Dailey, 1980]
	\hyperref[prob:kcolouring]{3-Colouring} is \hyperref[sec:NP]{NP-Complete} for planar graphs.
\end{theorem}
\begin{theorem}[Gr\"otzsch, 1980]
	Every triangle free planar graph is\hyperref[prob:kcolouring]{3-colourable} 
\end{theorem}
\section{Graph Theory}
\subsection{Definitions}
\begin{definition}[Graph]
	A graph $G=(V,E)$ is a set of vertices $V$ together with a set of edges $E \subset V \times V$.
\end{definition}
\begin{definition}[Subgraph]
	$H$ is a subgraph of $G$ if a copy of $H$ can be obtained from $G$ by deleting vertices and edges. 
\end{definition}
\begin{definition}[Induced Subgraph]
	$H$ is a subgraph of $G$ if a copy of $H$ can be obtained from $G$ by deleting vertices.
\end{definition}
\begin{definition}[Spanning Subgraph]
	$H$ is a subgraph of $G$ if a copy of $H$ can be obtained from $G$ by deleting edges.
\end{definition}
\begin{definition}[Minors]
	The graph $H$ is a minor of the graph $G$ if a copy of $H$ can be obtained by deleting vertices and deleting or contracting edges of $G$. 
\end{definition}
\begin{definition}[Induced Minors]
	The graph $H$ is a minor of the graph $G$ if a copy of $H$ can be obtained by deleting vertices and contracting edges of $G$. 
\end{definition}
\begin{definition}[Topological Minors]
	$H$ is a topological minor of $G$ if some sequence of subdivisions of $H$ results in an induced subgraph of $G$. An edge $(x,y)$ is subdivided by adding a vertex $z$ such that $N(z)= \{x,y\}$ 
\end{definition}

\subsection{Graph Classes}
	\begin{definition}[Hereditary Classes]
		A class of graphs $X$ is hereditary if, for any $G \in X$, every induced subgraph $H$ of $G$ also belongs to $X$.
	\end{definition}
	
	\begin{definition} [Forbidden Induced Subgraphs]
		$H$ is a minimal forbidden induced subgraph for the class $X$ if every proper induced subgraph of $H$ belongs to $X$ but $H$ itself does not. Any hereditary class is characterized by the avoidance of some set of minimal forbidden induced subgraphs $MFIS(X)$.
	\end{definition}

	\begin{definition} [Bipartite Graphs]
		A graph $G$ is bipartite if its vertices can be partitioned into (at most) two independent sets. A graph is bipartite if and only if it contains no odd cycle. Equivalently, the set of minimal forbidden induced subgraphs for the class of bipartite graphs is the set of all odd cycles.
	\end{definition}

	\begin{definition} [Planar Graph]
		A graph $G$ is planar if it can be drawn without any of the edges crossing.
	\end{definition}
\subsection{Graphs}
\end{document}
